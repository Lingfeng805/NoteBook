# 我的第一本算法书

## 2. 排序

- **冒泡排序**：重复“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置”；
- **选择排序**：重复“从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换”；
  - 在序列中寻找最小值：使用**线性查找**；
- **插入排序**：从序列左端开始一次对数据进行排序，左侧数据陆续归位，右侧留下未被排序的数据，从右侧未排序区域内取出一个数据，将其插入到左边已排序区域内合适的位置。
- **堆排序**：循环“先取出根节点（最顶端）的数——重构堆结构——取出根节点的数——重构堆结构”
  - **堆**：1.每个结点最多两个子节点；2.子节点数据必须大于父节点数据；（按**升序**构建的堆）
    - 取出数据：先取出根节点的数据（最顶端），将最后的数据移动到最顶端，再跟进堆的规则调换位置。
- **归并排序**：先把序列分成长度相同的两个子序列，当无法继续下分时（每个子序列只有一个数据时），对子序列进行归并。
  - **归并**：将两个排好序的子序列合并为一个有序序列；
- **快速排序**：1.随机选择一个基准值；2.将除基准值以外的所有数分为两类：比基准值大的、比基准值小的；
  - 【比基准值小的数】基准值【比基准值大的数】
  - 对【】内数据继续排序（也使用快速排序）



## 3.数组的查找

- **线性查找**：从头开始不断地按顺序检查数据。时间复杂度O(n);
- **二分查找**：只能查找已经*排好序*的数据。通过比较数组中间的数据与目标数据的大小，可得知目标数据是在数组的左边还是右边。比较一次就可把查找范围缩小一半。时间复杂度O(logn);



## 4.图的搜索

- **图**：由顶点（结点）和连接每对顶点的边所构成的图形。
- **加权图**：给边加上一个值（权重），没有权重的边只能表示两个顶点的连接状态，而有权重的边可以表示顶点之间的“连接程度”。
- **有向图**：给边加上箭头。

### 4-2 广度优先搜索

- 优先从离起点近的顶点开始搜索，由近及远进行广泛的搜索。因此，目标顶点离起点越近，搜索结束得越快。

### 4-3 深度优先搜索

- 沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。

### 4-4 贝尔曼-福特算法

- 一种在图中求解最短路径问题的算法。
- 首先，设置各个顶点的初始权重：起点为0，其他顶点为无穷大。（该权重值表示从起点到该顶点的最短路径的暂定距离）
