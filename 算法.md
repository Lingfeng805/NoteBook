# 我的第一本算法书

## 2. 排序

- **冒泡排序**：重复“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置”；
- **选择排序**：重复“从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换”；
  - 在序列中寻找最小值：使用**线性查找**；
- **插入排序**：从序列左端开始一次对数据进行排序，左侧数据陆续归位，右侧留下未被排序的数据，从右侧未排序区域内取出一个数据，将其插入到左边已排序区域内合适的位置。
- **堆排序**：循环“先取出根节点（最顶端）的数——重构堆结构——取出根节点的数——重构堆结构”
  - **堆**：1.每个结点最多两个子节点；2.子节点数据必须大于父节点数据；（按**升序**构建的堆）
    - 取出数据：先取出根节点的数据（最顶端），将最后的数据移动到最顶端，再跟进堆的规则调换位置。
- **归并排序**：先把序列分成长度相同的两个子序列，当无法继续下分时（每个子序列只有一个数据时），对子序列进行归并。
  - **归并**：将两个排好序的子序列合并为一个有序序列；
- **快速排序**：1.随机选择一个基准值；2.将除基准值以外的所有数分为两类：比基准值大的、比基准值小的；
  - 【比基准值小的数】基准值【比基准值大的数】
  - 对【】内数据继续排序（也使用快速排序）



## 3.数组的查找

- **线性查找**：从头开始不断地按顺序检查数据。时间复杂度O(n);
- **二分查找**：只能查找已经*排好序*的数据。通过比较数组中间的数据与目标数据的大小，可得知目标数据是在数组的左边还是右边。比较一次就可把查找范围缩小一半。时间复杂度O(logn);



## 4.图的搜索

- **图**：由顶点（结点）和连接每对顶点的边所构成的图形。
- **加权图**：给边加上一个值（权重），没有权重的边只能表示两个顶点的连接状态，而有权重的边可以表示顶点之间的“连接程度”。
- **有向图**：给边加上箭头。

### 4-2 广度优先搜索

- 优先从离起点近的顶点开始搜索，由近及远进行广泛的搜索。因此，目标顶点离起点越近，搜索结束得越快。

### 4-3 深度优先搜索

- 沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。

### 4-4 贝尔曼-福特算法

- 一种在图中求解**最短路径**问题的算法。
- 首先，设置各个顶点的初始权重：起点为0，其他顶点为无穷大。（该权重值表示从起点到该顶点的最短路径的暂定距离）
- 计算两个端点之间的权重，“顶点原本的权重+边的权重”，若计算结果**小于**该顶点的值，就更新该值。
- 图的顶点数为n、边数为m; 时间复杂度：O(nm)
- 【特点】边的权值可以是**负数**，但当一个**闭环**中边的总和总是负数，那么只要不断遍历这个闭环路径的权重就能不断减小，即**不存在最短路径**。**对顶点进行n次更新操作后仍能继续更新的情况，可直接认定它不存在最短路径**

### 4-5 狄克斯特拉算法

- 一种在图中求解**最短路径**问题的算法。
- 首先，设置各个顶点的初始权重：起点为0，其他顶点为无穷大。
- 选择从当前所在顶点直达且尚未被搜索过的顶点，设为**候补顶点**；
- 计算各候补顶点的权重，计算结果小于候补顶点的值，就更新该值；
- 从候补顶点中选择权值较小的那个继续上述操作，直至到达目标顶点。
- 图的顶点数为n、边数为m; 时间复杂度：O($n^2$),若对数据结构进行优化，时间复杂度变为：O(m+nlogn)。
- 【特点】**不支持**含负数的权重；效率比贝尔曼-福特算法**高**。（即在不存在负数权重时，更适合使用效率更高的狄克斯特拉算法；而存在负数权重时，即便较为耗时，也应该使用贝尔曼-福特算法）

### 4-6 $A^*$算法

- 一种在图中求解**最短路径**问题的算法。
- 是由狄克斯特拉算法发展而来，狄克斯特拉算法会从离起点近的顶点开始，按顺序求出起点到各个顶点的最短路径，即一些离终点较远的顶点的最短路径也会被计算处理，但这部分其实无用；$A^*$会预估一个值，并利用该值来省去一些无用的计算。
- 如一开始可以获得一些启发信息，即各个顶点到终点的大致距离，就可以使用$A^*$算法。距离估算值越接近实际值，$A^*$算法的搜索效率越高。反之，则效率越差，甚至无法获得正确答案。

